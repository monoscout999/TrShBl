[
    {
        "name": "Physics-Point",
        "prompt": "Generate ONLY JavaScript. Class Point. Properties: x, y, oldx, oldy, pinned. Verlet Integration: update() applies gravity and velocity (x - oldx). constrain() keeps inside canvas. Code: class Point { constructor(x, y) { this.x = x; this.y = y; this.oldx = x; this.oldy = y; this.pinned = false; } update(friction, gravity, groundFriction) { if(this.pinned) return; const vx = (this.x - this.oldx) * friction; const vy = (this.y - this.oldy) * friction; this.oldx = this.x; this.oldy = this.y; this.x += vx; this.y += vy + gravity; } constrain(width, height) { if(this.x > width) { this.x = width; this.oldx = this.x + (this.x - this.oldx)*0.5; } else if(this.x < 0) { this.x = 0; this.oldx = this.x + (this.x - this.oldx)*0.5; } if(this.y > height) { this.y = height; this.oldy = this.y; this.x += (this.x - this.oldx) * 0.1; } else if(this.y < 0) { this.y = 0; } } } window.Point = Point;",
        "output": "physics/point.js"
    },
    {
        "name": "Physics-Stick",
        "prompt": "Generate ONLY JavaScript. Class Stick. Properties: p1, p2, length, stiffness. update() solves distance constraint. Code: class Stick { constructor(p1, p2) { this.p1 = p1; this.p2 = p2; this.length = Math.hypot(p2.x - p1.x, p2.y - p1.y); } update() { const dx = this.p2.x - this.p1.x; const dy = this.p2.y - this.p1.y; const dist = Math.sqrt(dx*dx + dy*dy); const diff = this.length - dist; const percent = diff / dist / 2; const offsetX = dx * percent; const offsetY = dy * percent; if(!this.p1.pinned) { this.p1.x -= offsetX; this.p1.y -= offsetY; } if(!this.p2.pinned) { this.p2.x += offsetX; this.p2.y += offsetY; } } } window.Stick = Stick;",
        "output": "physics/stick.js"
    },
    {
        "name": "Physics-Engine",
        "prompt": "Generate ONLY JavaScript. Class Engine. Properties: points, sticks, gravity=0.5, friction=0.999. update(): updates points, solves sticks (3 iterations), constrains points. Code: window.Engine = { points: [], sticks: [], gravity: 0.5, friction: 0.999, width: 800, height: 600, update: function() { this.points.forEach(p => { p.update(this.friction, this.gravity); p.constrain(this.width, this.height); }); for(let i=0; i<5; i++) { this.sticks.forEach(s => s.update()); } } };",
        "output": "physics/engine.js"
    },
    {
        "name": "Entity-Ragdoll",
        "prompt": "Generate ONLY JavaScript. Class Ragdoll. Constructor(x, y). Creates Points for Head, Neck, Shoulders, Elbows, Hands, Hips, Knees, Feet. connects them with Sticks. Returns lists. Code: class Ragdoll { constructor(x, y) { const p = (ox, oy) => { const pt = new Point(x+ox, y+oy); Engine.points.push(pt); return pt; }; const s = (p1, p2) => { const st = new Stick(p1, p2); Engine.sticks.push(st); return st; }; this.head = p(0, 0); const neck = p(0, 25); const torso = p(0, 80); const lElbow = p(-20, 40); const lHand = p(-40, 60); const rElbow = p(20, 40); const rHand = p(40, 60); const hips = p(0, 100); const lKnee = p(-15, 140); this.lFoot = p(-20, 190); const rKnee = p(15, 140); this.rFoot = p(20, 190); s(this.head, neck); s(neck, torso); s(neck, lElbow); s(lElbow, lHand); s(neck, rElbow); s(rElbow, rHand); s(torso, hips); s(hips, lKnee); s(lKnee, this.lFoot); s(hips, rKnee); s(rKnee, this.rFoot); s(this.head, torso); s(lElbow, torso); s(rElbow, torso); s(hips, this.head); } } window.Ragdoll = Ragdoll;",
        "output": "entities/ragdoll.js"
    },
    {
        "name": "Entity-Animator",
        "prompt": "Generate ONLY JavaScript. Object Animator. animate(ragdoll) method. Uses Math.sin(Date.now()) to move feet/knees slightly to simulate walking or idle breathing. Code: window.Animator = { update: function(ragdolls) { const time = Date.now() * 0.005; ragdolls.forEach(r => { r.lFoot.x += Math.sin(time) * 1; r.rFoot.x += Math.cos(time) * 1; r.lFoot.y -= Math.abs(Math.sin(time)) * 0.5; }); } };",
        "output": "entities/animator.js"
    },
    {
        "name": "Viz-Renderer",
        "prompt": "Generate ONLY JavaScript. Object Renderer. draw(points, sticks). Draw lines for sticks, circles for points. Code: window.Renderer = { canvas: null, ctx: null, init: function() { this.canvas = document.getElementById('canvas'); this.ctx = this.canvas.getContext('2d'); this.width = this.canvas.width = window.innerWidth; this.height = this.canvas.height = window.innerHeight; Engine.width = this.width; Engine.height = this.height; }, draw: function() { const ctx = this.ctx; ctx.clearRect(0,0,this.width, this.height); ctx.lineWidth = 4; ctx.strokeStyle = 'white'; ctx.beginPath(); Engine.sticks.forEach(s => { ctx.moveTo(s.p1.x, s.p1.y); ctx.lineTo(s.p2.x, s.p2.y); }); ctx.stroke(); ctx.fillStyle = 'red'; Engine.points.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); }); } };",
        "output": "viz/renderer.js"
    },
    {
        "name": "Input-Handler",
        "prompt": "Generate ONLY JavaScript. Object Input. Mouse drag logic. Nearest point query. Code: window.Input = { dragPoint: null, init: function() { const c = document.getElementById('canvas'); c.onmousedown = e => { let min = 1000, nearest = null; Engine.points.forEach(p => { const d = Math.hypot(p.x - e.clientX, p.y - e.clientY); if(d < 50 && d < min) { min = d; nearest = p; } }); this.dragPoint = nearest; }; window.onmousemove = e => { if(this.dragPoint) { this.dragPoint.x = e.clientX; this.dragPoint.y = e.clientY; this.dragPoint.oldx = e.clientX; this.dragPoint.oldy = e.clientY; } }; window.onmouseup = () => this.dragPoint = null; } };",
        "output": "input.js"
    },
    {
        "name": "Main-Loop",
        "prompt": "Generate ONLY JavaScript. Init everything. Game Loop. Spawn 3 Ragdolls. Code: window.Main = { ragdolls: [], init: function() { Renderer.init(); Input.init(); for(let i=1; i<=3; i++) { this.ragdolls.push(new Ragdoll(200*i, 100)); } this.loop(); }, loop: function() { Engine.update(); Animator.update(this.ragdolls); Renderer.draw(); requestAnimationFrame(() => this.loop()); } }; window.onload = () => Main.init();",
        "output": "main.js"
    },
    {
        "name": "HTML-Index",
        "prompt": "Generate ONLY HTML5. Canvas fullscreen. Import modules: physics/point.js, physics/stick.js, physics/engine.js, entities/ragdoll.js, entities/animator.js, viz/renderer.js, input.js, main.js. Code: <!DOCTYPE html><html><head><style>body{margin:0;background:#222;overflow:hidden}canvas{display:block}</style></head><body><canvas id='canvas'></canvas><div style='position:absolute;top:10px;left:10px;color:white;font-family:sans-serif'>Drag ragdolls to throw them!</div><script src='physics/point.js'></script><script src='physics/stick.js'></script><script src='physics/engine.js'></script><script src='entities/ragdoll.js'></script><script src='entities/animator.js'></script><script src='viz/renderer.js'></script><script src='input.js'></script><script src='main.js'></script></body></html>",
        "output": "index.html"
    }
]